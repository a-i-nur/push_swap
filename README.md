*This project has been created as part of the 42 curriculum by aakhmeto.*

# Push Swap

## Description
push_swap is a program that sorts a stack of integers using only a limited set
of operations on two stacks (A and B). The goal is to produce the smallest
number of operations for each input.

This repository follows a clear plan: build on libft, design a clean project
structure, implement the core algorithm, add bonus features, and document the
choices.

## Instructions

### Build
```bash
make
```

### Run
```bash
./push_swap 3 2 1
```

The program prints the list of operations to stdout. You can verify the result
with the checker (if available in your setup).

## Theory Notes

### Stack Basics
- Stack is a LIFO structure: last in, first out.
- `top` is the element where operations are applied.
- `bottom` is the oldest element in the stack.
- `push` moves the top element from one stack to the other.
- `pop` removes the top element (for push_swap this is done by `push`).

### Invariants
- All values must be unique (subject rules).
- The total number of elements across A and B stays constant.
- After sorting, stack A is in ascending order and stack B is empty.

### Indexing
Instead of sorting raw values, each value can be replaced by its index in the
sorted order. This makes comparisons simpler and keeps values in a small range.

### Complexity
- For small inputs, simple algorithms like insertion sort can be efficient.
- For larger inputs, divide-and-conquer strategies are better.
- Complexity is usually explained in Big-O notation.

### Sorting Algorithms (options)
- `qsort` from libc (not allowed for push_swap but useful for reference).
- QuickSort (fast average case, but bad worst case).
- MergeSort (stable, guaranteed O(n log n), uses extra memory).
- HeapSort (O(n log n), in-place).
- InsertionSort (good for very small n).

### Searching / Indexing Strategies
- Binary search on a sorted array (classic, O(log n)).
- Sort pairs (value, pointer_to_node) and assign indexes in O(n).
- Hash map value -> index (O(1) average), extra memory and setup.

### Algorithm Choice Rationale
In the documentation and code comments, describe which algorithm is used,
why it was chosen, and what alternatives were considered. Mention the
time complexity and any trade-offs.

## Resources
- 42 push_swap subject (project description and constraints).
- Algorithms: CLRS (Cormen, Leiserson, Rivest, Stein).
- Sorting overview: https://en.wikipedia.org/wiki/Sorting_algorithm
- Searching overview: https://en.wikipedia.org/wiki/Search_algorithm

### AI Usage
AI was used only to rewrite and structure the README in simple English based on
existing notes. No code was generated by AI in this project.
