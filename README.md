*This project has been created as part of the 42 curriculum by aakhmeto.*

# Push Swap

## Description
push_swap is a program that sorts a stack of integers using only a limited set
of operations on two stacks (A and B). The goal is to produce the smallest
number of operations for each input.

Allowed operations (each line printed counts as 1 move; `ss`, `rr`, `rrr` are
single moves even though they act on both stacks):
- `sa`: swap the first 2 elements of stack A.
- `sb`: swap the first 2 elements of stack B.
- `ss`: `sa` and `sb` at the same time.
- `pa`: push the top element from B to A.
- `pb`: push the top element from A to B.
- `ra`: rotate A (first element becomes last).
- `rb`: rotate B (first element becomes last).
- `rr`: `ra` and `rb` at the same time.
- `rra`: reverse rotate A (last element becomes first).
- `rrb`: reverse rotate B (last element becomes first).
- `rrr`: `rra` and `rrb` at the same time.

Benchmarks for maximum score (subject requirements):
- 100 random numbers: fewer than 700 operations.
- 500 random numbers: no more than 5500 operations.

## Instructions

### Build
```bash
make
```

Other make targets:
```bash
make bonus    # builds checker if bonus is implemented
make clean    # removes object files
make fclean   # removes objects and binaries
make re       # full rebuild
```

### Run
```bash
./push_swap 3 2 1
```

The program prints the list of operations to stdout. You can verify the result
with the checker (if available in your setup).

### Checker (manual)
If you have a checker binary (bonus or provided by the subject):
```bash
./push_swap 3 2 1 | ./checker 3 2 1
```
On Linux with the provided binary:
```bash
./push_swap 3 2 1 | ./checker_linux 3 2 1
```

### Benchmarks and average (AVG)
Run the included benchmark script (uses 10 runs by default):
```bash
./tests/run_tests.sh
```

Compute average operations over N random cases (replace N and SIZE):
```bash
N=20 SIZE=100
python3 - <<'PY'
import os, random, subprocess, statistics
n = int(os.environ["N"])
size = int(os.environ["SIZE"])
counts = []
for _ in range(n):
    arr = random.sample(range(-1000000, 1000000), size)
    ops = subprocess.check_output(["./push_swap", *map(str, arr)], text=True)
    counts.append(len([l for l in ops.splitlines() if l.strip()]))
print("avg:", round(statistics.mean(counts), 2), "max:", max(counts))
PY
```

## Theory Notes

### Stack Basics
- Stack is a LIFO structure: last in, first out.
- `top` is the element where operations are applied.
- `bottom` is the oldest element in the stack.
- `push` moves the top element from one stack to the other.
- `pop` removes the top element (for push_swap this is done by `push`).

### Invariants
- All values must be unique (subject rules).
- The total number of elements across A and B stays constant.
- After sorting, stack A is in ascending order and stack B is empty.

### Indexing
Instead of sorting raw values, each value can be replaced by its index in the
sorted order. This makes comparisons simpler and keeps values in a small range.

### Complexity
- For small inputs, simple algorithms like insertion sort can be efficient.
- For larger inputs, divide-and-conquer strategies are better.
- Complexity is usually explained in Big-O notation.

### Sorting Algorithms (options)
- `qsort` from libc (not allowed for push_swap but useful for reference).
- QuickSort (fast average case, but bad worst case).
- MergeSort (stable, guaranteed O(n log n), uses extra memory).
- HeapSort (O(n log n), in-place).
- InsertionSort (good for very small n).

### Searching / Indexing Strategies
- Binary search on a sorted array (classic, O(log n)).
- Sort pairs (value, pointer_to_node) and assign indexes in O(n).
- Hash map value -> index (O(1) average), extra memory and setup.

### Algorithm Choice Rationale
In the documentation and code comments, describe which algorithm is used,
why it was chosen, and what alternatives were considered. Mention the
time complexity and any trade-offs.

## Resources
- 42 push_swap subject (project description and constraints).
- Algorithms: CLRS (Cormen, Leiserson, Rivest, Stein).
- Merge sort: `https://en.wikipedia.org/wiki/Merge_sort`
- Binary search: `https://en.wikipedia.org/wiki/Binary_search_algorithm`
- LIS (greedy / patience sorting): `https://en.wikipedia.org/wiki/Longest_increasing_subsequence`
- Sorting overview: `https://en.wikipedia.org/wiki/Sorting_algorithm`
- Searching overview: `https://en.wikipedia.org/wiki/Search_algorithm`

### AI Usage
AI was used only to edit this README: translate Russian notes to English,
expand instructions, and add resource links. No code was generated by AI in this
project.

## Algorithm (very simple explanation)
Below is a simplified view of the current sorting strategy in this project.
The explanation is intentionally basic.

### Terms
- Stack: like a pile of plates; you can only take the top.
- A and B: two stacks used to reorder numbers.
- Index: position of a value in sorted order (smallest = 0).
- LIS: longest increasing subsequence (already-in-order part).
- Pivot: a middle value used to split elements when pushing to B.
- Cost: number of moves needed to place a value.
- rr/rrr: rotating both stacks together is cheaper than separately.

### Core idea
1) Keep only the LIS in A (already mostly sorted).
2) Push all other elements to B.
   - If a value in B is greater than the pivot, rotate B so big values go down.
3) Move everything back from B to A:
   - Always choose the cheapest element to place (minimal moves).
   - If possible, rotate both stacks together (rr/rrr).
4) Finally rotate A so the smallest index is on top.

### Metaphor
Imagine arranging books by height on a shelf (A).
Some books are already in order (LIS) â€” do not touch them.
The rest go into a box (B), then return one by one, always picking the book
that is easiest to place correctly.

### Example with 5 numbers
Numbers: 4 1 3 2 5  
Indexes: 3 0 2 1 4  
LIS (one possible): 0 2 4 -> stay in A.  
Others (1, 3) go to B.  
Then return from B with minimal rotations, and finally rotate A so index 0 is on top.
