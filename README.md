*This project has been created as part of the 42 curriculum by aakhmeto.*

# Push Swap

## Description
push_swap is a program that sorts a stack of integers using only a limited set
of operations on two stacks (A and B). The goal is to produce the smallest
number of operations for each input.

This repository follows a clear plan: build on libft, design a clean project
structure, implement the core algorithm, add bonus features, and document the
choices.

## Instructions

### Build
```bash
make
```

### Run
```bash
./push_swap 3 2 1
```

The program prints the list of operations to stdout. You can verify the result
with the checker (if available in your setup).

## Theory Notes

### Stack Basics
- Stack is a LIFO structure: last in, first out.
- `top` is the element where operations are applied.
- `bottom` is the oldest element in the stack.
- `push` moves the top element from one stack to the other.
- `pop` removes the top element (for push_swap this is done by `push`).

### Invariants
- All values must be unique (subject rules).
- The total number of elements across A and B stays constant.
- After sorting, stack A is in ascending order and stack B is empty.

### Indexing
Instead of sorting raw values, each value can be replaced by its index in the
sorted order. This makes comparisons simpler and keeps values in a small range.

### Complexity
- For small inputs, simple algorithms like insertion sort can be efficient.
- For larger inputs, divide-and-conquer strategies are better.
- Complexity is usually explained in Big-O notation.

### Sorting Algorithms (options)
- `qsort` from libc (not allowed for push_swap but useful for reference).
- QuickSort (fast average case, but bad worst case).
- MergeSort (stable, guaranteed O(n log n), uses extra memory).
- HeapSort (O(n log n), in-place).
- InsertionSort (good for very small n).

### Searching / Indexing Strategies
- Binary search on a sorted array (classic, O(log n)).
- Sort pairs (value, pointer_to_node) and assign indexes in O(n).
- Hash map value -> index (O(1) average), extra memory and setup.

### Algorithm Choice Rationale
In the documentation and code comments, describe which algorithm is used,
why it was chosen, and what alternatives were considered. Mention the
time complexity and any trade-offs.

## Resources
- 42 push_swap subject (project description and constraints).
- Algorithms: CLRS (Cormen, Leiserson, Rivest, Stein).
- Sorting overview: https://en.wikipedia.org/wiki/Sorting_algorithm
- Searching overview: https://en.wikipedia.org/wiki/Search_algorithm

### AI Usage
AI was used only to rewrite and structure the README in simple English based on
existing notes. No code was generated by AI in this project.

## Алгоритм (очень простыми словами)
Ниже описано, как работает текущая версия сортировки в этом проекте.
Объяснение максимально простое, как для школьника.

### Определения
- Стек: это стопка тарелок. Можно взять только верхнюю.
- A и B: два стека. Мы перекладываем числа между ними.
- Индекс: это "место числа в отсортированном списке". Самое маленькое = 0.
- LIS: "самая длинная возрастающая цепочка". Это как уже почти собранная часть.
- Пивот (pivot): середина среди тех, кого мы будем выталкивать в B.
- Цена (cost): сколько движений нужно, чтобы поставить число на место.
- rr/rrr: одновременные вращения двух стеков (дешевле, чем по одному).

### Идея алгоритма
1) Сначала мы оставляем в A только LIS (то, что уже почти отсортировано).
2) Всё остальное отправляем в B.
   - Если число в B больше пивота, прокручиваем B вниз, чтобы большие ушли вниз.
3) Потом возвращаем всё из B обратно в A, но не как попало:
   - Каждый раз выбираем самое "дешёвое" число (минимум движений).
   - Если можно крутить оба стека вместе, крутим вместе (rr/rrr).
4) В конце доворачиваем A так, чтобы самое маленькое стало сверху.

### Метафора
Представь, что ты собираешь книжки по росту на полке (A).
Часть книг уже стоят по порядку (LIS) — их трогать нельзя.
Остальные ты временно складываешь в коробку (B).
Потом возвращаешь книги по одной, каждый раз выбирая ту,
которую проще всего поставить на правильное место.

### Пример на 5 числах
Числа: 4 1 3 2 5
Индексы: 3 0 2 1 4
LIS (например): 0 2 4 -> остаются в A.
Остальные (1, 3) идут в B.
Дальше возвращаем из B так, чтобы минимально крутить стеки.
В конце минимальный индекс (0) поднимаем вверх.
